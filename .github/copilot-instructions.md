# Lar Feliz Animal – AI Agent Guide
- **Stack & entrypoints**: Next.js 15 App Router with TypeScript (`src/app/**`), Tailwind, shadcn, Framer Motion. `src/app/layout.tsx` wires theming, Firebase, favorites, analytics, and shared header/footer.
- **Firebase bootstrap**: `src/firebase/client-provider.tsx` + `src/firebase/index.ts` lazily init the Firebase JS SDK on the client and expose `useAuth/useFirestore`. Server code (metadata, API routes) calls the same `initializeFirebase` helper, so guard for missing env vars before using it.
- **Environment**: copy `.env.example` into `.env.local`; blank Firebase keys make the client providers return `null` (and surfaces console warnings). Dev server runs on port 9002 via `npm run dev` (Turbopack enabled).
- **Data model**: Firestore collections (`animals`, `shelters`, `users`, `adoptionApplications`, `config/site`) mirror the schemas in `docs/backend.json` and `src/lib/types.ts`. Update the JSON first when adding fields; the generated `src/firebase/config.ts` should stay untouched.
- **Firestore hooks**: Use `useCollection`/`useDoc` (in `src/firebase/firestore`) to subscribe to queries. They emit `FirestorePermissionError` events that `FirebaseErrorListener` converts into dev-time throws or user-facing toasts—keep new Firestore calls inside these hooks or emit errors manually for consistency.
- **Favorites state**: `FavoritesProvider` (`src/hooks/use-favorites.tsx`) keeps IDs in `localStorage` and prunes missing animals with chunked Firestore lookups. Favor using it instead of bespoke favorites logic so pruning and persistence continue to work.
- **Auth flow**: `src/app/login/page.tsx` handles email/password + Google sign-in with hCaptcha verification. After successful auth, client state comes from Firebase `onAuthStateChanged` (`useUser`). Protected pages (e.g., `favorites`, `matcher`, `admin`) gate on this hook rather than assuming synchronous availability.
- **Access control**: Middleware (`src/middleware.ts`) currently only filters obvious public paths; anything sensitive must still re-check `useUser` or validate Firebase ID tokens server-side. Admin API routes call `requireOperator` (`src/lib/server/require-operator.ts`) which expects a `Bearer <Firebase ID token>` header and cross-checks the `users` doc for the `operator` role.
- **API routes**: `src/app/api` hosts small Node runtimes—registration, admin user provisioning, and hCaptcha verification. They rely on `getAdminServices` for Firebase Admin access; ensure `FIREBASE_ADMIN_*` vars exist before invoking.
- **hCaptcha**: On the client use `<HCaptchaChallenge />` (`src/components/hcaptcha/challenge.tsx`). The verify endpoint falls back to a manual fetch if the `hcaptcha` package fails to load.
- **UI system**: Shared UI lives under `src/components/ui`. Prefer composing from these primitives (Radix-based) and reuse `cn` helper for Tailwind class merging.
- **Animations**: Wrapping pages/components in `MotionOrchestrator`, `PageTransition`, `StaggerContainer`, and `Reveal` (see `src/components/animations/**`) keeps reveal timings consistent; add new animations through these orchestrators.
- **Routing patterns**: Public marketing pages (home, education, FAQ) are mostly static client components. Data-heavy screens (`adopt`, `favorites`, `matcher`) fetch Firestore client-side—avoid server components unless you have an admin credential available.
- **Admin surface**: Administrative UI (under `src/app/admin/**`) assumes the `users` collection stores roles; stay consistent with `AppUser` type when expanding permissions.
- **Notices & toasts**: Use `useToast` (`src/hooks/use-toast.ts`) for transient feedback and respect the app’s destructive/default variants so theming stays coherent.
- **Testing & linting**: Project favors `npm run lint` and `npm run typecheck`; automated tests are placeholders (`npm run test` mentioned but not wired). Run these before shipping significant code.
- **Deploy**: Vercel is the documented path; remember to set hCaptcha, Firebase client/admin keys, and optional GA measurement ID in the environment.

Let me know if any sections need more depth or if other workflows should be documented.
